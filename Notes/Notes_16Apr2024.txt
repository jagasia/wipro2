16-Apr-2024
----------------
[8:47 am] Unknown User
Hello Everyone, Good Morning! if you have any issues with Cloud Labs, please ping here or Raise a Help-desk Ticket Visit:
https://techsupport.rpsconsulting.in/

OR Call At 9921716110 (Ulhas) for Immediate Support                                                                                                       

HAPPY LEARNING! Have a Nice DayðŸ˜Š RPS Tech Support 

customer support platform

RPS TechSupport

customer support platform

RPS TechSupport

customer support platform
RPS TechSupport
customer support platform
------------------------------------------
Solution for square and tower problem:
import java.util.Scanner;

public class App {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int sideLength=sc.nextInt();		//5
		int city[][]=new int[sideLength][sideLength];
		int noOfTowers=sc.nextInt();		//3
		int positions[][]=new int[noOfTowers][2];
		for(int i=0;i<noOfTowers;i++)
		{
			//i dont need j loop just for 2 co ordinates
			positions[i][0]=sc.nextInt();
			positions[i][1]=sc.nextInt();
		}
		sc.close();
		//now fix "1" in locations where towers are present in city array
		//for each tower, we need to put 1 in city at x and y
		for(int i=0;i<noOfTowers;i++)
		{
			int x=positions[i][0];
			int y=positions[i][1];
				
			//a tower covers 3 mts including tower location. 
//			so every adjacent location should be marked as 1
			
			//x +-1		x+0	x+1	,,,,,,,,,,,	y+-1	y+0	y+1
			//diagonal		x+1 y+1			x-1	y-1
			//diagonal		x+1 y-1			x-1	y+1
			
			//problem is 		index should not go out of bounds
			for(int m=-1;m<=1;m++)
			{
				for(int n=-1;n<=1;n++)
				{
//					System.out.printf("m=%d\tn=%d\n",m,n);
					int x1=x+m;
					int y1=y+n;
					if(x1>=0 && x1<sideLength && y1>=0 && y1<sideLength)
					{
						city[x1][y1]=1;
					}
				}
			}
			
			
			
		}
		
		//check city now
//		for(int i=0;i<sideLength;i++)
//		{
//			for(int j=0;j<sideLength;j++)
//			{
//				System.out.print(city[i][j]+"\t");
//			}
//			System.out.println();
//		}
		
		//count the 0s in city array. If no 0s then Yes. Else No and display the count
		int zeroCount=0;
		for(int i=0;i<sideLength;i++)
			for(int j=0;j<sideLength;j++)
				if(city[i][j]==0)	zeroCount++;
		
		System.out.println((zeroCount>0)?"No\n"+zeroCount:"Yes");
	}

}

---------------------------------------------------
Mobile Lock Pattern 
 
Given the coordinates of  a lock pattern configuration, check whether it is a Valid Lock Pattern or not. A valid Lock pattern will be formed only by joining the adjacent neighbours.  If it is a valid lock pattern and if there is 
       1)   Above 75% coverage, print "Excellent", 
       2)  Above 50% coverage, print "Good", 
       3)  Above 25% coverage, print "Average", 
       4)  Else print "Poor". 

(Coverage need to be calculated with respect to the total grid size) 

        If it is an  invalid lock pattern, print "Invalid". 

Assume that the pattern grid will always be a square. 
Note: 
To make the problem less complicated the following relaxations are made: 
1) The testcases will not contain any overlap through a point in the pattern. 
2) The pattern will always end at a new point. 
3) The points given in the testcases always lie within the pattern grid. No need to check if the point is outside the grid. 


Input Format: 
The first line is an integer that corresponds to the side length of the pattern grid. 
The second line is an integer that corresponds to the number of coordinates in the lock pattern, n. 
The following n lines have the following pattern : x-coor y-coor 

Output Format: 
Print "Invalid" if there is the pattern is not properly linked, else print "Excellent " or "Good" or "Average" or "Poor", based on the number of points covered. 

Sample Input 1: 
3 
5 
1 1 
2 1 
3 1 
2 2 
3 3 
Sample Output 1: 
Good 

Sample Input 2: 
3 
6 
1 1 
2 1 
3 1 
2 2 
3 1 
3 3 
Sample Output 2: 
Invalid
-----------------------------------------
Explanation:

Sample Input 1: 
3 			screen width.		3 * 3	 totally 9 points in the screen
5 			pattern covers 5 points. 	next 5 inputs are x,y co ordinates
1 1 	
2 1 
3 1 
2 2 
3 3 
Sample Output 1: 
Good  

What you have to do?
	check if every consequtive points are adjacent or not.


NOTE:
	All these co ordinates are 1 ordinal.


Solution:
-----------
import java.util.Scanner;

public class App {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int screenWidth=sc.nextInt();
		int noOfPoints=sc.nextInt();
		int [][]points=new int[noOfPoints][2];
		for(int i=0;i<noOfPoints;i++)
		{
			points[i][0]=sc.nextInt();
			points[i][1]=sc.nextInt();
		}
		sc.close();
		
		//your code here
		//start from first point, compare with next point.
		for(int i=0;i<noOfPoints-1;i++)
		{
//			System.out.printf("%d,%d compared with %d,%d\n",points[i][0],points[i][1],points[i+1][0],points[i+1][1]);
			int x1=points[i][0];
			int y1=points[i][1];
			
			int x2=points[i+1][0];
			int y2=points[i+1][1];
			
			//absolute difference between them must be maximum 1
			if(Math.abs(x1-x2)>1 || Math.abs(y1-y2)>1)
			{
				System.out.println("Invalid");
				System.exit(0);
			}
			
			
		}
		//check coverage
		int coverage=(int) (100*(float)noOfPoints/screenWidth);
		if(coverage>75)
		{
			System.out.println("Excellent");
		}else if(coverage>50)
		{
			System.out.println("Good");
		}else if(coverage>25)
		{
			System.out.println("Average");
		}
		else
		{
			System.out.println("Poor");
		}
		
		
	}

}
---------------------------------------------------------
String Handling
String Manipulation: Methods in the String Class
StringBuilder and StringBuffer: Mutability and Performance

String is peculiar.
String is not stored in heap. It was stored in Permanent Generation area till jdk 5
From java 8, String is stored in String pool.

String is immutable.
	What is meant by immutable?
		immutable means, cannot be changed.


basically, a variable should vary.
the value of the variable must be changeable.

But when it comes to String variable,
the variable holds the reference of the String.
the reference changes, when we assign another string.


Employee e1=new Employee();
e1.setSalary(220000);		//i am changing the value of salary, 	e1 still refers to the same memory.

e1 is referring to a memory in heap. it does not change when i change the content.

But in case of String, the reference change.

Another point of view about a String.

String str="Mumbai is called as Bombay";
//can we change "is" into "was"?


String is IMMUTABLE


		String str1=new String("Hello");
		String str2=new String("Hello");
		System.out.println(str1==str2);
		System.out.println(str1.equals(str2));



always use equals() method to compare the value of 2 strings.


Regular Expressions:	(regex)
---------------------------
Regular expression is a language with few set of symbols
that can be used to create a pattern and
	i) check if a string matches the pattern or not			boolean		true/false
	ii) extract the portions of the string that matches the pattern

Suppose, if you get an SMS from someone, which contains, for example:
	Kindly note this number and call this number immediately. The number is 987573429. If this number does not work, call using 04412121212. Thank 		you.

You dont have a paper and pen to note down these phone numbers.
How will you make a phone call by seeing this SMS?

	today's phones are capable of extracting only the
		phone numbers
		email addresses
	etc
	from a text.

So, in our program,
	how can we do this?

Task:
-------
input:
	Kindly note this number and call this number immediately. The number is 987573429. If this number does not work, call using 04412121212. Thank 		you.

output:
	
987573429
04412121212

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class AppRegex1 {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		String input=sc.nextLine();
		String exp="\\d+";
		Pattern p = Pattern.compile(exp);
		Matcher m = p.matcher(input);
		while(m.find())
		{
			System.out.println(m.group());
		}
		
	}

}


c>='0' && c<='9'

c>48 && c<(57)


Lets use regular expression to extract the portions of a String which matches the given pattern.

Pattern is made of symbols.

Regex symbols followed by multiplicity.
ex:
	\d+
here, \d is a symbol that refers to "digit"
	+ is the multiplicity that refers to "one or more"

multiplicity
+	one or more
*	zero or more
?	zero or one
{1}	one and only once
{1,}	one or more
{,5}	upto five
{1,3}	minimum 1 and maximum 3

symbols
\d	digit
\D	non digit
\s
\w
.	dot means it matches anything
[]	to specify the list of characters from which 1 can appear
	ex:
		[aeiou]	any vowel
		[a-z]	range of a to z from which 1 char
		[A-Za-z0-9]	any alphabet, lower or upper or number
		
()	to group and specify the multiplicity
|	pipe is used as OR operator
		you can specify () to create couple of groups and use | operator between 


Task:
--------
Accept input from the user and extract the employee ID from the input.
Note:
	Example for employee id:
		EMP001
		EMP123
		
Use regex to solve this problem.


Task:
-----------
Accept input from the user and extract only the date portions found in the input.

date format:
	dd-MMM-yyyy
	16-Apr-2024

MMM must be first letter capital and followed by 2 lower case alphabets
hypen must be there
yyyy is always 4 digits 	(remind me later for 2/4 digits after the break)


Demo:
--------
How to check if a String is matching a pattern or not.

Check if the given input is a valid mobile number or not.
Rules for a mobile number:
	must be a 10 digit number
	should not contain anything other than number
	first digit must be within the range of 6-9

Pattern:
	[6-9]{1}[0-9]{9}

//String class itself has matches() method

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class AppRegex2 {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		String mobileNo=sc.nextLine();
		//String class itself has matches() method
		if(mobileNo.matches("[6-9]{1}[0-9]{9}"))
		{
			System.out.println("Valid");
		}else
		{
			System.out.println("Invalid");
		}
	}

}

/*--Another way---------------*/
		if(Pattern.matches("[6-9]{1}[0-9]{9}", mobileNo))
		{
			System.out.println("Valid");
		}else
		{
			System.out.println("Invalid");
		}

----------------------------------------------
