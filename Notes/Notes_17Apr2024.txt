17-Apr-2024
----------------
String Handling
String Manipulation: Methods in the String Class
StringBuilder and StringBuffer: Mutability and Performance
Java Object-Oriented Programming (OOP) Basics
Object-Oriented Programming (OOP)
Classes and Objects: Definitions and Differences
Constructors: Purpose and Types
Encapsulation: Access Modifiers and Getters/Setters
Inheritance: Superclass and Subclass Relationships
Polymorphism: Method Overloading and Overriding
Organizing Code
Packages: Creating and Using Packages
Classpath: Understanding and Setting the Classpath
Java Modules: Modular Programming in Java
-------------------------------------------------------
Session on OOP
Do assignments from PCAT to till date (40 min) a portion
Session on OOP
Task related to OOP
Do assignments from PCAT to till date (40 min) a portion
Session on OOP
Task related to OOP
Do assignments from PCAT to till date (40 min) a portion
--------------------------------------------
OOP
Object Oriented Programming
---------------------------------------
	Procedure oriented programming
		i create functions
		and use those functions many times
	
		then C++ was introduced.
		C++ is Object oriented.

		
C++ has classes
	that boxes	
		variables and
		methods


in C language, we don't have classes.		global variables
in C++ we have classes	

in Java, we dont have global variables.	outside the class, we dont have any variables.
outside the box, there will be some controls given to the user. Properly.

abstraction and encapsulation.

Object oriented programming makes our project scalable.
Handles complexity.
Manageable
when the project size grows, still we need to handle that complexity.


OOP
	Abstraction
	Encapsulation
	Inheritance
	Polymorphism


Example:
	if we create a project for football game
	we define
		Ground
		Ball
		Player
			GoalKeeper
		Referee
		Score
we can define objects and their 
	properties
	behavior
interaction between each other.


Classes and objects

A class
	wraps data members and methods.

Data members
	variables
	constants
methods
	functions

static
final
transient
volatile

static
	a data member of a class can be static
	a method inside a class can be static
	a block inside a class can be static

	static block
	static method
	static data member

A static member of a class does not belong to any particular object of the class.

I can create many objects of a class. Each object can have separate instance data members. But all objects share the same static data member.
instance is opposite to static.

object is the instance of a class.			instance = object

public class Employee {
	Integer associateId;
	String name;
	static String companyName;
	
}

in this class Employee,
	what are the instance variables?
		associateId
		name
	
	what are the static variables?
		companyName

you understand the difference between static and instance?
	instance members are specific to every instance

Static method:
-------------------
	static method of a class can be called, even before any object of the class is created.
	so, a static method can access only static members of the class.		(member  may be variable or constant or method)

	now you understand, main method is static
	so main can access only static methods.
	if static method wants to access instance members
	then it should use instance to access

Static block:
----------------
	static
	{

	}
a static block executes very early even before the first line of main is executed.

in C++:
we can declare a static variable inside a function.

void display()	//c++
{
	static int count=0;		//in java this is NOT possible
	count++;
	cout<<count;
}

//if i call this display 5 times, then what will be output in c++?
1
2
3
4
5

instead of creating a new count variable whenever the display function is called,
static modifier makes the count variable retain its value. 


But in java, we cannot do that.
in java, static is at class level. Not at method level
-------------------------------------------------------
final
	means constant

	final int PASS_SCORE=50;

in java, all constants are in FULL_CAPITAL_LETTERS


why final data members need to be static?
	if Employee class has a final data member, then definitely no object is able to modify that value, hence it must be same for all.
	why not we make it static.
	If we make it static, then only 1 variable is available irrespective of any number of objects.
	if we do not make it static, then every object will have separate copy of this variable.


final class
final method
final data member of a class
final data member inside a method

final class:
	this class is final in the inheritance hierarchy
	hence, no other class is allowed to inherit this final class
	final class cannot become a super class

final method:
	sub classes cannot override a final method
	final method cannot be overridden 

final data member of a class
	is constant. We need to assign a value and cannot be changed

final variable	variable is opposite to final
say final data member

-----------------
transient
	transient member of class does not participate in serialization.
	transient member means non persistent.

	suppose, if i store an object of Employee in a file.
	transient member's value will not be stored in the file.

	not only file, database also.
--------------------
volatile
	volatile members are thread safe.
	Threads usually keep the value of variable in thread cache
	volatile members cannot be remembered by the thread cache. So it will read the volatile member from primary memory everytime.
---------------------
"Assignment 1: Pseudocode Development - Task: Write a detailed pseudocode for a simple program that takes a number as input, calculates the square if it's even or the cube if it's odd, and then outputs the result. Incorporate conditional and looping constructs.

Assignment 2: Flowchart Creation - Design a flowchart that outlines the logic for a user login process. It should include conditional paths for successful and unsuccessful login attempts, and a loop that allows a user three attempts before locking the account.

Assignment 3: Function Design and Modularization - Create a document that describes the design of two modular functions: one that returns the factorial of a number, and another that calculates the nth Fibonacci number. Include pseudocode and a brief explanation of how modularity in programming helps with code reuse and organization."
------------------------------------------
OOP
--------
While creating a class.
we create a class for many reasons.
1) An application/ a program that contains main method.
2) User defined type.
	ex:
		Employee	(id, name, department, salary)
	so this is a composite type we have created.
3) Entity class
	Object Relational Mapping	ORM
	there is a table in database called EMPLOYEES
	So every row in the table can be mapped to an object of Employee class.

A class name:
	should be a noun
	First letter of the class, and subsequent first letter of ever word must be in Upper case
	Pascal case
		Employee
		JavaStudent
		RetailCustomer
	
A class should not contain public variable.
the data members must be non-public.
It is a guideline. Not rule.

Why the data members should not be public?
	public data members provide unconditional access.
	So, it is possible that any value will be accepted by the public variables.

a variable cannot restrict the data. To some extent, the data type/ type will enforce some rule.
	int rollNo;		//it will allow any number in the range of int data type. But beyond that we cannot introduce rules.

But if a method accepts input, then the method is capable of introducing rules.

	public void setRollNo(int rollNo)
	{
		//here, executable code is allowed. Means, we can use if condition, switch case etc to validate the data for rollNo
		this.rollNo=rollNo;
	}

	public int getRollNo()
	{
		//can format the data to the required form
		return rollNo;
	}

the above methods are called as
	setters	/ accessors
	getters	/ mutators

if a class has non public data members and  provide access using getters and setters then we are doing 
Abstraction
and
Polymorphism

making the variable private or non-public, it is encapsulated 
providing access through public methods, it provides abstraction.


Encapsulation:
	en means a positive thing
	encapsulate means, wrap/ box the data inside a type.
	Boxing

Abstraction:
	means providing access on essential characteristics
	public methods.

------------------------------------
Task:
--------
https://github.com/jagasia/wipro2/blob/jag/Java/University_Req1.docx
	open the above link and download the problem statement word document.

1) create College class
2) private variables
3) getters and setters
	i will give demo on that
4) default constructor
5) constructor with arguments
6) toString method
7) equals method

Demo:
----------
university-req-1

import java.text.SimpleDateFormat;
import java.util.Date;

public class College {
	private String name;
	private String website;
	private String mobile;
	private String founder;
	private String location;
	private Integer numberOfDept;
	private Date startingDate;
	
	public College() {}

	public College(String name, String website, String mobile, String founder, String location, Integer numberOfDept,
			Date startingDate) {
		super();
		this.name = name;
		this.website = website;
		this.mobile = mobile;
		this.founder = founder;
		this.location = location;
		this.numberOfDept = numberOfDept;
		this.startingDate = startingDate;
	}
	
	

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getWebsite() {
		return website;
	}

	public void setWebsite(String website) {
		this.website = website;
	}

	public String getMobile() {
		return mobile;
	}

	public void setMobile(String mobile) {
		this.mobile = mobile;
	}

	public String getFounder() {
		return founder;
	}

	public void setFounder(String founder) {
		this.founder = founder;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public Integer getNumberOfDept() {
		return numberOfDept;
	}

	public void setNumberOfDept(Integer numberOfDept) {
		this.numberOfDept = numberOfDept;
	}

	public Date getStartingDate() {
		return startingDate;
	}

	public void setStartingDate(Date startingDate) {
		this.startingDate = startingDate;
	}

	@Override
	public String toString() {
		SimpleDateFormat sdf=new SimpleDateFormat("dd-MM-yyyy");
		return String.format("Name: %s\n"
				+ "Website: %s\n"
				+ "Mobile: %s\n"
				+ "Founder: %s\n"
				+ "Number of Dept: %d\n"
				+ "Location: %s\n"
				+ "Starting Date: %s\n"
				+ "", name, website, mobile, founder, numberOfDept, location, sdf.format(startingDate));
	}

	@Override
	public boolean equals(Object obj) {
		College arg=(College) obj;
		return this.getName().equalsIgnoreCase(arg.getName()) && this.getStartingDate().equals(arg.getStartingDate());
	}
	
	
}

---------------------------------------
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class App {

	public static void main(String[] args) throws ParseException {
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter college 1 detail:");
		String input1=sc.nextLine();
		System.out.println("Enter college 2 detail:");
		String input2=sc.nextLine();
		
//		SKCT,www.skct.edu.in,7402600200,BalaKrishna Naidu,6,kovaipudhur,20-05-1985	
		String[] arr1 = input1.split(",");
		College college1=new College();
		//setter based injection
		college1.setName(arr1[0]);
		college1.setWebsite(arr1[1]);
		college1.setMobile(arr1[2]);
		college1.setFounder(arr1[3]);
		college1.setNumberOfDept(Integer.valueOf(arr1[4]));
		college1.setLocation(arr1[5]);
		SimpleDateFormat sdf=new SimpleDateFormat("dd-MM-yyyy");
		Date startingDate=sdf.parse(arr1[6]);
		college1.setStartingDate(startingDate);
		
		String[] arr2 = input2.split(",");
		College college2=new College(arr2[0], arr2[1], arr2[2], arr2[3], Integer.valueOf(arr2[4]), arr2[5], sdf.parse(arr2[6]));
		//the above is constructor based injection
		System.out.println("College 1:");
		System.out.println(college1);	//automatically calls the toString method
		
		System.out.println("College 2:");
		System.out.println(college2);
		
		if(college1.equals(college2))
		{
			System.out.println("College 1 is same as College 2");
		}else
		{
			System.out.println("College 1 and College 2 are different");
		}
	}

}


------------------------------------------------












