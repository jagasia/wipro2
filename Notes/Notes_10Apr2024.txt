10-Apr-2024	Wednesday	Day #2
Logical Operators: AND, OR, NOT, XOR			
-----------------------------------------------
what is XOR?
	Returns TRUE only if both are not SAME
	TRUE XOR FALSE	=	TRUE
	FALSE XOR TRUE	=	TRUE
	TRUE XOR TRUE	=	FALSE
	FALSE XOR FALSE	=	FALSE

What is a fibonacci series?
	Addition of 1st 2 numbers becomes the 3rd number and repeat the same

x
y
x+y
y+(x+y)
(x+y)+y+(x+y)

what is the first number in fibonacci?
	0
next number is
	1

0
1
1
2
3
5
8
13
21
34
55
89
144

PRINT X
PRINT Y
X=Y
Y=X+Y

X=0
Y=1
Z=X+Y

X=Y
Y=Z

To make this algorithm/ flowchart as finite, we ask user to decide
	Fibonacci series until which number?
		then you need to check if the series number is > than input then exit
	or
	Fibonacci series of how many numbers?
		then you need a counter.

Task:
www.lucidchart.com
Intelligent Diagramming | Lucidchart

Sign up to lucid chart (if not already).
login to Lucid chart and 
Draw a flow chart for bubble sort algorithm.

Draw a flow chart for insertion sort algorithm.
--------------------------------
Searching algorithms:
--------------------------------

is
data[i] = item
?

Linear search:
	start searching from the first element
	and continue to search until
		the search item is found
		or
		the end of the list is reached

I give you time to complete these flow charts:

1) Fibonacci series flow chart
2) Bubble sort flow chart
3) Insertion sort flow chart
4) Linear search flow chart

----------------------------------------------
Binary search.
We have already discussed this in previous session.

Task:

Now, we have to draw flowchart for binary search
in lucid chart.

----------------------------------
Whenever an algorithm uses recursion,
i would recommend to find another algorithm that solve the same problem WITHOUT USING Recursion.
Why I dont like recursion?
	stack overlow

Suppose, I ask you the route to reach a place.
	now a days we use google map.
	if we dont have that facility, we will ask someone to help us with the route.
	that person says like this:
		to some extent, we will be able to grasp the route. But there is a limitation.
		all together, we cannot remember
		but when it comes to google map, we feel comfortable. WHY?
			because, the google map, tells you only one instruction at a time.
			in 600 meters, take left
			in 400 meters, take sharp right
			now, take U turn
		like this, it is telling one by one.

that is the difference between recursion and non recursion (loop)

recursion, push to stack
non recursion, is like queue (not even queue. queue also can store so many instructions in itself)
	one instruction -> you follow then remove that instruction from the queue
	

Lets take the example of Binary Search tree:
	how do we traverse a binary tree?
		Traverse means, visiting every node of the tree.
	3 traversal techniques:
		in order
		pre order
		post order

In Order:
	left 
	root
	right

Pre Order:
	root
	left
	right

Post Order
	left
	right
	root

All these are done using recursion:
-----------------------------------------------
push the nodes to the stack until we reach the leaf node
once we reach the leaf node, we start poping the nodes and display them



1 as left
left root right

final output:
1
3
4
6
7
8
10
13
14

in order traversal visits the binary search tree nodes 
in ascending order.

inorder(left)
inorder(root)
inorder(right)

preorder(root)
preorder(left)
preorder(right)

postorder(left)
postorder(right)
postorder(root)


Recursion is making the algorithm worst when the height of the tree is huge.
Stack overflow. Because, the root nodes are pushed to stack until the leaf node is reached.

So, how can we avoid recursion while 
traversing a binary search tree?

Without recursion, how to traverse a binary search tree?
	we need to do some change in the binary search tree.
	in that case, the name of the tree will become "Threaded binary search tree"

Threaded binary search tree:
	every node, contains reference to its in order successor

Node in a tree:
	LEFT
	RIGHT
	VALUE
	INORDERSUCCESSOR



Factorial
-------------
	factorial of 100

		range of a variable

		long
Finding factorial of a number without using recursion

input n
set factorial=1
for loop from n to 1	step -1
	factorial *= n

this will be sufficient

Task:
I want to list the sorting algorithms
and their order of growth in Big O notation.


Graph:
----------
Vertex and Edge
Vertices and Edges

Chennai	->	Hyderabad
		     |
		     V

	<-	Bengaluru




first we need created Vertices
and then create edges between vertices. We can add some value to these edges.

Chennai to Hyderabad	=	750 kms
Hyderabad to Bengaluru	=	580 kms
Bengaluru to Chennai	=	350 kms

i want to go from
	chennai to hyderabad via bengaluru

		350 + 580	=	930

	chennai to hyderabad	750


What is the shortest route from 1 to 5?
route 1:
1 -> 2 -> 3 -> 5
8+7+14	=	29
route 2:
1 -> 2 -> 5
8+4	=	12	BEST ROUTE
route 3:
1 -> 2 -> 8 -> 6 -> 5
8+2+6+2	=	18
route 4:
1 -> 7 -> 6 -> 5
11+1+2	=	14
route 5:
1 -> 0 -> 7 -> 6 -> 5
4+8+1+2	=	15


What is the difference between BFS and DFS in graph?
[12:20] Ajay
BFS uses the queue to keep track of the next location that it should visit.
[12:20] Komal Shivaji Londhe (Unverified)
BFS works on the concept of FIFO (First In First Out). 

DFS works on the concept of LIFO (Last In First Out).

BFS is more suitable for searching vertices closer to the given source.	

DFS is more suitable when there are solutions away from source.
[12:21] Ajay
Dfs uses the stack to keep track of the next location that it should visit

BFS uses Queue:

Queue:
	3	5

1 comes out.
another queue
	1	2	8	6	5

2 comes out
	2	8	6	5
	2	3	5


3 comes out
	
-------------------------
Hash Table
----------------
	what are the columns in hash table?
		Key	Offset

In java we have a datastructure called hashtable
	Hashtable

Key is a set. Set means, does not allow duplicates

key	value
1	India
2	Australia
3	Japan
3	China		Japan is replaced by China
null	Argentina
null	USA		Argentina is replaced by USA

values can be null.
can key be null?????????
	yes, one null is allowed
	second null means duplicate.

RDBMS
UNIQUE constraint allows NULL. How many NULLs allowed?		any number of NULLs allowed.
PRIMARY KEY does not allow NULL




import java.util.*;
public class App12
{
	
	public static void main(String args[])
	{
		HashMap<Integer, String> map=new HashMap<>();
		map.put(null,"Japan");
		map.put(null,"China");
		System.out.println(map);
	}
}



D:\Jag\wipro\Apr2024>java App12
{null=Japan}

D:\Jag\wipro\Apr2024>javac App12.java

D:\Jag\wipro\Apr2024>java App12
{null=China}

D:\Jag\wipro\Apr2024>




-- CREATE TABLE DUMMY
-- (
-- SNO INT unique,
-- NAME VARCHAR(20)
-- );

INSERT INTO DUMMY VALUES (NULL, 'China'); 

select * from dummy;


(null)	Japan
(null)	China

Entry
	key
	value

import java.util.Hashtable;

public class App {

	public static void main(String[] args) {
		Hashtable<Integer, String> countries=new Hashtable<>();
		countries.put(1, "India");
		countries.put(2, "Pakistan");
		countries.put(3, "Japan");
		countries.put(3, "China");
		
		System.out.println(countries);
	}

}


{3=China, 2=Pakistan, 1=India}


Hashing
Collision
Rehashing
Bucket hashing
these concepts are algo & ds concepts to learn in hashing chapter.

-------------------------------------------------------------------
Advanced Sorting and Searching			
Merge Sort, Quick Sort, and Heap Sort: Concepts and Pseudocode			

Merge sort:
----------------
	What is Merge sort?
		best sorting algorith



merge
	we should divide the list into multiple sorted list.

51
40
30
25
45
61
54
70
33
59

this is a list of random numbers.
Sorting this list using merge sort.

there are 10 elements in this list.
if you split this into 10 sub lists.
Then each sub list will contain, 1 element.
Now, i call, all my sub lists contain sorted manner.

now, merge the sub lists. So that 10 sub lists become 5 sub lists.

40
51

25
30

45
61

54
70

33
59

can you say, we have 5 sub lists and all are in sorted manner

25
30
40
51

33
45
54
59
61
70


now, we have 3 sub lists, in sorted manner

25
30
33
40
51
45
54
59
61
70

finally, we have sorted the large list

divide-and-conquer approach is used to sort this.

1,2,3,55,45,78,79,80

1,2,3,45,55,78,79,80

Efficiency of merge sort algorithm is
very high, when the list is almost already sorted.


Complexity Analysis of Merge Sort:
Time Complexity:

Best Case: O(n log n), When the array is already sorted or nearly sorted.
Average Case: O(n log n), When the array is randomly ordered.
Worst Case: O(n log n), When the array is sorted in reverse order.
Space Complexity: O(n), Additional space is required for the temporary array used during merging.

Advantages of Merge Sort:
Stability: Merge sort is a stable sorting algorithm, which means it maintains the relative order of equal elements in the input array.
Guaranteed worst-case performance: Merge sort has a worst-case time complexity of O(N logN), which means it performs well even on large datasets.
Simple to implement: The divide-and-conquer approach is straightforward.
Disadvantage of Merge Sort:
Space complexity: Merge sort requires additional memory to store the merged sub-arrays during the sorting process. 
Not in-place: Merge sort is not an in-place sorting algorithm, which means it requires additional memory to store the sorted data. This can be a disadvantage in applications where memory usage is a concern.
----------------------------------------------------------------
Quick Sort
---------------
Task:
	Identify what is quick sort
	how it is implemented
	and also its Order or growth,
	advantages and disadvantages.




